#==============================================================
#
#  Name: bsaDriver
#
#  Rem:  
#        EPICS driver module
#        LCLS-II Timing System
#
#  Side: None
#
#  Auth: 17-Mar-2017, Kukhee Kim      (KHKIM)
#  Rev:  dd-mmm-yyyy, Reviewer's Name (USERNAME)
#--------------------------------------------------------------
#  Mod:
#        dd-mmm-yyyy, Reviewer's Name (USERNAME)
#          coment
#
#==============================================================
#
# NOTE:

This is an epics driver module to provide BSA interface for LCLS-II High Performance System (HPS)
which is based on ATCA platform.
It provides epics shell command to configure/setup the BSA names and also provides epics database
templates for BSA PVs in epics ioc application.

Requirements:

- The epics ioc application should build with yamlLoader driver and with CPSW framework.

  API layer
  . cpsw/framework R4.1.2
  . yaml-cpp-0.5.3_boost-1.64.0
  . boost 1.64.0
  . timing/bsa R1.1.3

  configure/CONFIG_SITE.Common.<platform> in application should have the followings:

  CPSW_FRAMEWORK_PACKAGE_NAME=cpsw/framework
  CPSW_FRAMEWORK_VERSION=R4.1.2
  CPSW_FRAMEWORK=$(PACKAGE_AREA)/$(CPSW_FRAMEWORK_PACKAGE_NAME)/$(CPSW_FRAMEWORK_VERSION)/$(LINUXRT_BUILDROOT_VERSION)-x86_64
  CPSW_FRAMEWORK_LIB     = $(CPSW_FRAMEWORK)/lib
  CPSW_FRAMEWORK_INCLUDE = $(CPSW_FRAMEWORK)/include

  YAML_NAME=yaml-cpp
  YAML_VERSION=yaml-cpp-0.5.3_boost-1.64.0
  YAML_ARCH=$(LINUXRT_BUILDROOT_VERSION)-x86_64
  YAML=$(PACKAGE_AREA)/$(YAML_NAME)/$(YAML_VERSION)/$(YAML_ARCH)
  YAML_INCLUDE=$(YAML)/include
  YAML_LIB=$(YAML)/lib

  BOOST_PACKAGE_NAME=boost
  BOOST_VERSION=1.64.0
  BOOST_ARCH=$(LINUXRT_BUILDROOT_VERSION)-x86_64
  BOOST=$(PACKAGE_AREA)/$(BOOST_PACKAGE_NAME)/$(BOOST_VERSION)/$(BOOST_ARCH)
  BOOST_LIB     = $(BOOST)/lib
  BOOST_INCLUDE = $(BOOST)/include
 
  BSA_PACKAGE_NAME=timing/bsa
  BSA_VERSION=R1.1.3
  BSA_ARCH=$(LINUXRT_BUILDROOT_VERSION)-x86_64
  BSA=$(PACKAGE_AREA)/$(BSA_PACKAGE_NAME)/$(BSA_VERSION)/$(BSA_ARCH)
  BSA_LIB     = $(BSA)/lib
  BSA_INCLUDE = $(BSA)/include




  EPICS module
  . yamlLoader R1.1.3
  . asyn R4.31-0.1.0

  configure/RELEASE in application should have the followings:

  ASYN_MODULE_VERSION=R4.31-0.1.0
  YAMLLOADER_MODULE_VERSION=R1.1.3
  BSADRIVER_MODULE_VERSION=R1.5.5

  ASYN=$(EPICS_MODULES)/asyn/$(ASYN_MODULE_VERSION)
  YAMLLOADER=$(EPICS_MODULES)/yamlLoader/$(YAMLLOADER_MODULE_VERSION)
  BSADRIVER=$(EPICS_MODULES)/bsaDriver/$(BSADRIVER_MODULE_VERSION



  <application>/src/Makefile should have the follwings:


  <application>_DBD += asyn.dbd
  <applicaiton>_DBD += yamlLoader.dbd
  <application>_DBD += bsaAsynDriver.dbd

  <application>_LIBS += cpsw
  <application>_LIBS += bsa
  <applicaiton>_LIBS += asyn
  <application>_LIBS += yamlLoader
  <application>_LIBS += bsaDriver

  
- The yamlLoader driver should provide register hierarchy and path information.
- The application firmware should have BSA functionallity

yamlLoader Driver:

- the yamlLoader driver should load up the hierarchy file before BSA initialization

ex)  cpswLoadYamlFile("000TopLevel.yaml", "NetIODev", "", "10.0.3.105")

- please, check up more details in README file in yamlLoader driver 


Adding BSA names for the driver:

- before the driver intialization, ioc application engineer should make BSA name list.
- the order of the name should be matched with the BSA data order in application firmware.
- the driver provides ioc shell command "addBsa(<BSA name string>, <BSA data type string>"),
   ioc engineer can use the command to add up bsa name into the list
- the driver proides ioc shell command "listBsa()" to print out the BSA name list,
   ioc engineer could verify the bsa name list with the command
   
ex) 
# ====================================
# Setup BSA Driver
# ====================================
# add BSA 
addBsa("PIDL",       "uint32")
addBsa("PIDU",       "uint32")
addBsa("TSL",        "uint32")
addBsa("TSU",        "uint32")
addBsa("RATES",      "uint32")
addBsa("BEAMREQ",    "uint32")
addBsa("BEAMNRG01",  "uint32")
addBsa("BEAMNRG23",  "uint32")
addBsa("MPSSTAT",    "uint32")
addBsa("MPSCLASS01", "uint32")
addBsa("MPSCLASS23", "uint32")

ex) 
vioc-b84-ev01>listBsa()
Total 31 BSA(s) has(have) been registered
        0       PIDL, uint32
        1       PIDU, uint32
        2       TSL, uint32
        3       TSU, uint32
        4       RATES, uint32
        5       BEAMREQ, uint32
        6       BEAMNRG01, uint32
        7       BEAMNRG23, uint32
        8       MPSSTAT, uint32
        9       MPSCLASS01, uint32
        
        
Adding Slave BSA names for the driver
- The slave BSA shares BSA data source with master.
- It could have different data conversion - separate slope and offset from the master BSA
- After creating master BSA node, create slave BSA node as the followings:

  addSlaveBsa(<BSA name for master>, <BSA name for slave>, "uint32")

- The "BSA name for master" should exist when adding the slave
- The "BSA name for slave" will be used for the BSAKEY for dbLoadRecords()


ex) 
  addSlaveBsa("PIDL", "pidlSlave0", "uint32")
  addSlaveBsa("PIDL", "pidlSlave1", "uint32")
  addSlaveBsa("PIDL", "pidlSlave2", "uint32")
  addSlaveBsa("PIDL", "pidlSlave3", "uint32")
  addSlaveBsa("PIDL", "pidlSlave4", "uint32")
  addSlaveBsa("PIDL", "pidlSlave5", "uint32")
  
  In this example, we added up 6 slave BSAs for PIDL BSA.
  
  listBsa()
  Total 31 BSA(s) has(have) been registered
        0       PIDL, double
                +----- slave node 0     pidlSlave0, uint32
                +----- slave node 1     pidlSlave1, uint32
                +----- slave node 2     pidlSlave2, uint32
                +----- slave node 3     pidlSlave3, uint32
                +----- slave node 4     pidlSlave4, uint32
                +----- slave node 5     pidlSlave5, uint32
        1       PIDU, uint32
        2       TSL, uint32
        3       TSU, uint32
        
  listBsa() command shows master node and its slave nodes
  
  
  
BSA Data Tytpe

BSA driver and firmware allow {"int32", "uint32", "float32"} type of data.
If firmware doesn't calculate statistics (mean and rms) all 3 types are allowed.
If firmware calculate statstics, only "int32" type is allowed.


driver initialization:
- the driver provide ioc shell command 
  "bsaAsynDriverConfigure(<asyn port name for BSA>, <path for register space>, <path for dram space>)"
  for the driver initialization
- the driver initialization command should be called after completing the hierarchy loading by yamlLoader driver
  and also after the BSA name list is built.
- the register path and dram path should be consistent with the hierarchy files.
  (in the example, ROOT path of hierarchy is NetIODev,
   the register space is located at NetIODev/mmio/AmcCarrierTimingGenerator/AmcCarrierCore/AmcCarrierBsa,
   and the stream dram is located at NetIODev/strm/AmcCarrierDRAM/dram.)

ex)  bsaAsynDriverConfigure("bsaPort", "mmio/AmcCarrierTimingGenerator/AmcCarrierCore/AmcCarrierBsa","strm/AmcCarrierDRAM/dram")


Enable/Disable BSA:

After the driver initialization, the BSA can be disabled and enabled anytime via the following commands:

    bsaAsynDriverEnable()
    bsaAsynDriverDisable()

The bsaAsynDriverConfigure() command enables BSA as a default (backward compatible).



EPICS database template loading:

- the driver module provide epics database template for the BSA history buffer PVs
- the template has few macros to set up PV name, BSA name and BSA buffer length for the history buffer PVs
- followings are an example BSA history buffer

  $(DEV):$(SECN)HST<n>          ; BSA history for average value
  $(DEV):$(SECN)CNTHST<n>       ; number of samples for an average value
  $(DEV):$(SECN)RMSHST<n>       ; RMS value
  $(DEV):$(SECN)PIDUHST<n>      ; pulse id upper word
  $(DEV):$(SECN)PIDLHST<n>      ; pulse id lower word
  
  $(DEV)         ; macro
  $(SECN)        ; macro, bsa PV name
  $(BSAKEY)      ; macro, bsa key, it should be matched with the bsa name string in addBsa()
  
  $(PORT)        ; macro, asyn port name for bsa driver, should be matched with the port name in the driver initialization

  <n>            ; given instance number / name
        [0..55]   BSA slot number for general use
	1H        pre-programmed BSA for 1Hz continuous acquisition
        TH        pre-programmed BSA for 10Hz continuous acquisition
        F1        reserved BSA slot for fast feedback
        F2        reserved BSA slot for fast feedback
        FLTB0     reserved BSA slot for fault buffer
        FLTB1     reserved BSA slot for fault buffer
        FLTB2     reserved BSA slot for fault buffer
        FLTB3     reserved BSA slot for fault buffer
 
ex) 

# BSA driver DB
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=PIDU,SECN=PIDU")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=PIDL,SECN=PIDL")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=TSU,SECN=TSU")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=TSL,SECN=TSL")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=RATES,SECN=RATES")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=BEAMREQ,SECN=BEAMREQ")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=BEAMNRG01,SECN=BEAMNRG01")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=BEAMNRG23,SECN=BEAMNRG23")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=MPSSTAT,SECN=MPSSTAT")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=MPSCLASS01,SECN=MPSCLASS01")

# PIDL has Slave BSAs
#
#   Test Slave Bsa Node
# 
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave0,SECN=PIDLSL0")
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave1,SECN=PIDLSL1")
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave2,SECN=PIDLSL2")
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave3,SECN=PIDLSL3")
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave4,SECN=PIDLSL4")
dbLoadRecords("db/bsa.db", "DEV=TPG:SYS2:1,PORT=bsaPort,BSAKEY=pidlSlave5,SECN=PIDLSL5")




- the database template loading can be located before driver initialization



BSA buffer length change and Fault buffer length change

The BSA buffer length and Fault buffer length are fixed (BSA length: 20000 and Fault buffer length: 1000000)
We do not suppose, end user need to change it, but the bsaDriver has way to make change the lengths.

the buffer lengths is defined in epics ioc shell variables. you cna check up the values as the followings.

example) 

    epics>var bsa_length
    bsa_length = 20000
    epics>var fltb_length
    fltb_length = 100000

You cna change the variable with "var" command, but you should make change prior than any of BSA driver related command.

example) we are going to make double length for both buffer. 

    epics>var bsa_length 40000
    epics>var fltb_length 2000000

You can also change the waveform length with two macros: BSA_LENGTH, FLTB_LENGTH.
If you do not specify the macors, these have 20000 and 1000000 as default values.

example)

dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=PIDU,SECN=PIDU,BSA_LENGTH=40000,FLTB_LENGTH=2000000")
dbLoadRecords("db/bsa.db", "DEV=TPG2:BSA,PORT=bsaPort,BSAKEY=PIDL,SECN=PIDL,BSA_LENGTH=40000,FLTB_LENGTH=2000000")






Linear Conversion

BSA database template has slope and offset PVs for each bsa name (bsakey).
The linear conversion affect the followings:

  bsa_data       = slope * raw_bsa_data + offset
  bsa_rmsa_value = slope * raw_rms_value
  
  
Slope and Offset PV names are:

  $(DEV):$(SECN)_SLOPE
  $(DEV):$(SECN)_OFFSET
  
These will be in autosave list.
The database template bsa.db has default value for SLOPE=1 and OFFSET=0.
These will be override by the autosave, once the user setting is saved.


# End of file
